---
layout: post
title: MySql存储引擎InnoDB和MyISAM的比较
tag: [database]
keywords: 子非吾,MySql,存储引擎,storage engine,技术博客,it
---
#MySql存储引擎InnoDB和MyISAM的比较

MySql的架构大概可以分为两层，服务器层和存储引擎层。存储引擎主要负责数据和索引的存储方式，和读写方式，它直接和底层数据打交道，服务器层只需要调用存储引擎的接口便可完成各种增删改查。MySql的这种架构可以将数据行为和服务器行为分开，因此我们称MySql的这种方式为插件式的存储引擎。

MySql有很多的存储引擎，MyISAM、InnoDB、Momery、Archive、CSV、Merge、NDB等等，这其中又以MyISAM和InnoDB最为常见和使用最为广泛。这篇文章主要介绍这种引擎的不同，以方便大家在决定该使用哪种引擎的时候能更好的做决定。

注：如无特殊说明本文以MySql5.6为例。

###数据文件
MySql会在数据目录下为每张表建立一个`表名.frm`的文件，该文件保存了表结构信息。这个文件只和schema有关，和数据、索引都无关，而且每张表都有一个如此的文件。至于数据和索引的存储则交给存储引擎负责。

#####MyISAM引擎
MyISAM引擎会为每张表建立另外两个文件：`表名.myd`和`表名.myi`。myd文件用来存储表数据，myi文件则用来存放索引。

MyISAM支持3种存储格式：静态固定长度（Fixed），动态可变长度(Dynamic)和压缩（Compressed）。当然三种格式中 是否压缩是完全可以任由我们自己选择的，可以在创建表的时候通过 ROW_FORMAT 来指定 {COMPRESSED | DEFAULT}，也可以通过myisampack工具来进行压缩，默认是不压缩的。在非压缩的情况下，是静态和是动态，默认是有表字段的定义决定的，如果表中含有可变长度的类型（varchar，blob，text），那么默认就是动态可变长度的，相反则是静态固定长度的。当然，我们可以通过alter table table_name row_format fixed|dynamic去自由转换这两种方式，转换的结果是，varchar变为char（这里说的转换的结果是指的存储方式，并不是字段的类型变化了，desc table_name看到的还是varchar）。注意当表里有blob或text字段时是不能做这种转换的，因为这两种类型没有最大长度限制或者说他们的最大长度大于char类型的最大长度，所以不能转换。MyISAM的三种存储格式中，静态格式就最简单也是最安全的（至少对于崩溃而言）。静态格式也是最快的on-disk格式。快速来自于数据文件中的行在磁盘上被找到的容易方式：当按照索引中的行号查找一个行时，用行长度乘以行号。同样，当扫描一个表的 时候，很容易用每个磁盘读操作读一定数量的记录。对于动态存储更为复杂一点，因为每行有一个表明行有多长的头。当一个记录因为更新的结果被变得更长，该记录也可以在超过一个位置处结束。可以使用OPTIMIZE TABLE或myisamchk来对一个表整理碎片。如果在一个表中有你频繁访问或改变的固定长度列，表中也有一些可变长度列，仅为避免碎片而把这些可变长度列移到其它表可能是一个好主意。

#####InnoDB引擎
MySql通过.frm文件存储表的数据字典信息（表结构），不同于其他存储引擎的是，InnoDB同时也会在表空间的内部数据字典中保持一份该信息。当删除一张表或者整个数据库时，MySql删除.frm文件的同时，也会在内部字典中删除关联的条目。因此，你不能只通过移动.frm文件达到在不同数据库之间移动InnoDB数据表的目的。

InnoDB采用共享表空间（tablespace）的形式，数据和索引都存储在表空间中。表空间是由InnoDB管理的一个黑盒子，有一系列数据文件组成。当然也可以将每个表的数据和索引存放在单独的文件中来改变这种默认行为。

###事务

InnoDB是仅有的支持事务的几个存储引擎之一，因此如果你的应用希望支持事务，那么InnoDB很可能就是你的选择。通过应用程序去实现事务往往是不被赞成的做法，因为你无法实现的像InnoDB这样高效。

MyISAM不支持事务。

###并发策略（锁）
锁是一种常见的并发控制策略。

按照本文最开始的，将MySql简单粗暴的分为两层架构，那么服务器层为我们实现了表级锁，即锁的粒度是表这个级别的，一个锁可以锁住整张表，所以这种锁开销最小，实现最简单，但是并发性最低。行级锁则由存储引擎实现，在MySql中InnoDB和XtraDB实现了行级锁。行级锁和表级锁相反，开销大、实现复杂，但是并发性高。

另外，InnoDB还实现了MVCC（多版本并发控制），可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。关于MVCC在本文中不会详细介绍，有兴趣请自行google或关注之后的文章。

因此，对于大量写操作，首选InnoDB引擎，因为它的行锁决定了它支持更高的并发；如果这些写操作大多是insert的话，MyISAM也是可以考虑的，可以通过concurrent insert（并发插入）提高性能。这是一种在有读锁的时候，仍然可以插入数据的策略。


###索引方式
#####InnoDB引擎
每个InnoDB表都有一个特殊的索引：聚簇索引（clustered index）。聚簇索引可以简单的理解为数据和索引在一起，普通的索引都是记录该条记录在磁盘中的位置，而聚簇索引则是直接在索引中保存了该条记录的数据。这是InnoDB在索引方面和其他引擎最大的区别。

因为聚簇索引的这个特性，聚簇索引可以说是主键的同义词。

为了获取查询、插入等其他操作的最佳性能，我们必须了解InnoDB如何使用聚簇索引优化普通查询和DML操作的。

* 当我们定义了一个主键，InnoDB会把它作为聚簇索引。所以我们推荐为每一个InnoDB表建一个主键。如果没有一个逻辑上唯一并且不为空的字段或字段集，那么添加一个自增的列作为主键。
* 如果一个表没有主键，那么MySql会把第一个不为空的唯一索引当做聚簇索引。
* 如果没有主键和上面一条说的合适的唯一索引，InnoDB会在内部创建一个隐藏的自增主键作为聚簇索引。

所以如果希望不创建主键来节约空间的朋友要注意了，在InnoDB中这个优化是行不通的。

通过聚簇索引查询一条记录是非常快的，因为索引和该条记录的所有列数据在一起，无需回表操作，因此聚簇索引和其他将索引和数据分开存放的索引相比要少一次IO操作。

其他的非聚簇索引都称之为二级索引（secondary index），在InnoDB中，二级索引的每条内容包含一个该条记录的主键信息，InnoDB通过这个主键值再去聚簇索引中查询需要的值。所以如果主键很长的话，二级索引会占用更多的空间，最好使用较短的主键。


###全文索引
从MySql5.6开始，InnoDB开始支持全文索引了。再此之前，只有MyISAM支持全文索引。

###参照完整性约束

参照完整性也叫引用完整性，主要通过外键实现。然后在MyIsam中却没有实现引用完整性，也就是数据在保持时MySql不会去检查外键的对应的值在关联表中是否真的存在，初学者可能都不会注意到这个问题。所以，在我们的开发中，如果使用的是MyIsam引擎，看到外键约束的时候，最好还是多留个心眼，在应用程序中要检查参照完整性。

InnoDB支持参照完整性约束。

###数据的安全性
如前文所说，InnoDB是支持事务的，为了实现事务的安全性，每一个事务都会写日志，我们称之为Redo log。这个日志中记录了事务中的所有写操作。MySql在事务提交时，会先写这个日志，然后真正的执行写操作，所以从这个日志中，我们可以看到所有的数据变化。如果一个事务在执行过程中发生例如断电这样的故障，在服务器下次重启后，MySql会根据这个日志把数据恢复到正确的状态。所以说，redo log使数据是安全的。提供了我们从灾难中恢复的机会。

其实，我们的每个操作都是一个事务，因为默认的`autocommit = 1`，所以即使我们没有显式的使用事务的commit，这个日志还是会存在的，并且一直工作的。

对于MyISAM表，MySql可以手工或者自动执行检查和修复操作（手动检查使用`check table`语句，修复使用`repair table`语句；自动修复在my.cnf配置中mysqld部分设定myisam-recover参数）。这里说的修复和事务的恢复是两个不同的概念，执行表的修复可能会导致一些数据丢失，而且修复是非常慢的。另外，如果服务器已经关闭，也可以通过myisamchk命令行工具进行检查和修复。


所以从安全性来讲，InnoDB的数据安全性是比MyIsam要高的。

###表相关数据的保存

在我们的开发中，常常可以听到“MyISAM引擎的统计比InnoDB要快的多“，这句话是片面的。MyISAM会在内部统计全表的行数，所以在执行`select * from table`的操作时无需扫描表，只要直接返回这个结果就行，这个操作的复杂度是O(1)。如果有where条件的统计查询，MyISAM是否还有如此好的效率呢？答案肯定是否定的。这个时候MyISAM和其他引擎没有区别都需要扫描一遍表或者索引。
