---
layout: post
title: MySql分区表
tag: [database]
keywords: 子非吾,MySql,分区表,partition,技术博客,it
---
#MySql分区表

###分区表概述
随着大数据时代的到来，应用的数据以大幅度的速度增长。如果仅仅处理过百万级的数据你都不好意思和别人打招呼，动不动上亿条的数据随处可见。如果我们还是使用传统的关系型数据库，面对这样的数据是否还能玩转呢？你是否打算使用索引？很可惜，在这种数量级时，索引往往起不了作用。这时候内存早就放不下这么多的数据了，就算使用了索引，成千上万的回表导致大量的随机IO也会消耗大量的时间。唯一可以寄希望的可能是覆盖索引了，但是到了这个时候，索引自身的维护都成了问题，索引太大，写入超慢，所以不得不另谋蹊径。    
在不切换数据库的情况下，最直接的解决方案可能就是分表了。分表的原理是将大数据分成很多的小份，每次都这些小份去操作，这样就可以快速的完成操作。不过，分表的结果就是需要大量修改应用逻辑，工作量蛮大。今天要说的分区表和分表采用同样的思想，缺不需要我们去修改应用逻辑。    
对用户来说，分区表是一个独立的逻辑表，但是底层却是由多个物理子表组成。这些子表和普通的表没有任何区别，也有自己的索引。操作分区表的过程其实就是对一组底层表的操作。所以分区对于SQL层来说是一个完全封装底层实现的黑盒子，对应用是透明的。    
MySql实现分区表的方式：对底层表的封装，意味着索引也是按照分区的字表定义的，没有全局的索引。    
在创建分区表的时候，我们会定义每个分区存放的数据。在执行查询时，优化器会根据分区定义过滤掉那些没有我们需要数据的分区，因为查询不需要扫描所有分区，只回查询有我们需要的数据的分区。

###分区表操作原理
前面说过，分区表有多个底层表实现，这些底层表和普通表一样，我们也可以直接访问各个分区，分区表的索引就是在各个底层表上各自加上一个完全相同的索引。对存储引擎来说，底层表和普通表没有任何区别，存储引擎也无须知道这是一个普通表还是一个分区表的底层表。
分区表的操作按照下面的逻辑进行：

#####select
分区层打开并锁住所有底层表，然后优化器判断是否可以过滤分区，然后调用调用存储引擎接口访问各个分区
#####insert
分区层打开并锁住所有底层表，然后根据插入的数据判断应该插入到哪个分区，再调用存储引擎接口写入数据
#####delete
分区层打开并锁住所有底层表，然后确定数据所在的分区，最后对底层表进行删除操作
#####update
分区层打开并锁住所有底层表，MySql先确定要更新的数据在哪些分区，然后取出数据，更新数据，再判断更新后的数据应该放在哪个分区，最后对底层表进行写入操作，并对原数据进行删除

虽然每个操作都会“分区层打开并锁住所有底层表”，但是这并不是说分区表在处理过程中采用的是表锁。如果存储引擎实现了自己的锁，如innoDB的行锁，则会在分区层释放对应的表锁。这个加锁和解锁过程和普通innoDB上的查询是类似的。
   
	
###分区表类型
MySql支持多种类型的分区表，如下：

#####range分区	
range分区根据范围进行分区，每个分区存储处在某个范围内的记录，分区表达式可以是列，也可以是列的表达式。如下就是一个创建range分区表的过程：
  
  ```
  create table partition_range(
	id int not null auto_increment,
	year int not NULL,
	primary key(id, year)
  ) engine=MyISAM
    PARTITION by RANGE(year)(
	  partition p0 values less than (2010),
	  partition p1 values less than (2012),
	  partition p2 values less than (2013),
	  partition p3 values less than MAXVALUE
  )
  ```
  这个表中我们建了一个主键`primary key(id, year)`，在下节分区表的限制中会讲到。如果只使用id为主键会报如下错误：
  
  	Error : A PRIMARY KEY must include all columns in the table's partitioning function #主键必须包含所有在分区表达式中的列
  	
或者为了测试简单，我们不要主键。

RANGE分区在如下场合特别有用：

* 当需要删除大量的“旧的”数据时。只需简单地使用 “ALTER TABLE partition_range DROP PARTITION p0；” 就可以删掉p0分区上的所有数据，这表执行一个delete的sql效率高多了
* 想要使用一个包含有日期或时间值，或包含有从一些其他级数开始增长的值的列
* 经常运行直接依赖于用于分区列的查询。例如经常执行"select * from table where year = 2013"，这样的查询，MySql会迅速的确定只有p2分区需要扫描

#####list分区
敬请期待
  
#####hash分区
敬请期待

#####key分区
敬请期待

#####子分区
敬请期待

###分区表使用场景和限制
任何的技术都有其适用的场景，在下面的场景中，分区可以起到非常大的作用：

* 表非常大，以至于无法全部放到内存中，或者只在表的最后部分有热点数据，其他均是历史数据
* 分区表的维护更容易，因此想批量删除大量数据可以使用清楚整个分区的方法。另外，还可以独立对一个分区进行优化、检查、修复、备份、恢复等操作
* 分区表的数据可以分布在不同的设备上，从而高效地利用多个硬件设备
* 可以使用分区表来避免某些特殊的瓶颈，例如innoDB的单个索引的互斥访问等

 
 以上场景可以让分区尽可能的发挥它的作用，同时分区也有自己的一些限制，下面是比较重要的几点：
 
 + 一个表最多有1024个分区
 + 有些情况下分区表达式必须是整数，或者返回整数的表达式
 + 如过有唯一键（包括主键），那么所有的唯一键必须都包含分区字段
 + 分区表中无法使用外键约束
 + 不是所有存储引擎都支持

###分区表维护
敬请期待