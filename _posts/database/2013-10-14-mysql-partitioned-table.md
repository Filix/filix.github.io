---
layout: post
title: MySql分区表
tag: [database]
keywords: 子非吾,MySql,分区表,partition,技术博客,it
---
#MySql分区表

###分区表概述
随着大数据时代的到来，应用的数据以大幅度的速度增长。如果仅仅处理过百万级的数据你都不好意思和别人打招呼，动不动上亿条的数据随处可见。如果我们还是使用传统的关系型数据库，面对这样的数据是否还能玩转呢？你是否打算使用索引？很可惜，在这种数量级时，索引往往起不了作用。这时候内存早就放不下这么多的数据了，就算使用了索引，成千上万的回表导致大量的随机IO也会消耗大量的时间。唯一可以寄希望的可能是覆盖索引了，但是到了这个时候，索引自身的维护都成了问题，索引太大，写入超慢，所以不得不另谋蹊径。
    
在不切换数据库的情况下，最直接的解决方案可能就是分表了。分表的原理是将大数据分成很多的小份，每次都这些小份去操作，这样就可以快速的完成操作。不过，分表的结果就是需要大量修改应用逻辑，工作量蛮大。今天要说的分区表和分表采用同样的思想，缺不需要我们去修改应用逻辑。    

对用户来说，分区表是一个独立的逻辑表，但是底层却是由多个物理子表组成。这些子表和普通的表没有任何区别，也有自己的索引。操作分区表的过程其实就是对一组底层表的操作。所以分区对于SQL层来说是一个完全封装底层实现的黑盒子，对应用是透明的。  
  
MySql实现分区表的方式：对底层表的封装，意味着索引也是按照分区的字表定义的，没有全局的索引。    
在创建分区表的时候，我们会定义每个分区存放的数据。在执行查询时，优化器会根据分区定义过滤掉那些没有我们需要数据的分区，因为查询不需要扫描所有分区，只回查询有我们需要的数据的分区。

###分区表操作原理
前面说过，分区表有多个底层表实现，这些底层表和普通表一样，我们也可以直接访问各个分区，分区表的索引就是在各个底层表上各自加上一个完全相同的索引。对存储引擎来说，底层表和普通表没有任何区别，存储引擎也无须知道这是一个普通表还是一个分区表的底层表。
分区表的操作按照下面的逻辑进行：

#####select
分区层打开并锁住所有底层表，然后优化器判断是否可以过滤分区，然后调用调用存储引擎接口访问各个分区
#####insert
分区层打开并锁住所有底层表，然后根据插入的数据判断应该插入到哪个分区，再调用存储引擎接口写入数据
#####delete
分区层打开并锁住所有底层表，然后确定数据所在的分区，最后对底层表进行删除操作
#####update
分区层打开并锁住所有底层表，MySql先确定要更新的数据在哪些分区，然后取出数据，更新数据，再判断更新后的数据应该放在哪个分区，最后对底层表进行写入操作，并对原数据进行删除

虽然每个操作都会“分区层打开并锁住所有底层表”，但是这并不是说分区表在处理过程中采用的是表锁。如果存储引擎实现了自己的锁，如innoDB的行锁，则会在分区层释放对应的表锁。这个加锁和解锁过程和普通innoDB上的查询是类似的。
   
	
###分区表类型
MySql支持多种类型的分区表，如下：

#####range分区	
range分区根据范围进行分区，每个分区存储处在某个范围内的记录，分区表达式可以是列，也可以是列的表达式。如下就是一个创建range分区表的过程：
  
	create table partition_range(
		id int not null auto_increment,
		year int not NULL,
		primary key(id, year)
  	) engine=MyISAM
    	PARTITION by RANGE(year)(
	  	partition p0 values less than (2011),
	  	partition p1 values less than (2012),
	  	partition p2 values less than (2013),
	  	partition p3 values less than MAXVALUE
  	)
  
这个表中我们建了一个主键`primary key(id, year)`，至于为什么要这样做在下节分区表的限制中会讲到。如果只使用id为主键会报如下错误：
  
  	Error : A PRIMARY KEY must include all columns in the table's partitioning function #主键必须包含所有在分区表达式中的列
  	
或者为了测试简单，我们也可以不要主键。

RANGE分区在如下场合特别有用：

* 当需要删除大量的“旧的”数据时。只需简单地使用 “ALTER TABLE partition_range DROP PARTITION p0；” 就可以删掉p0分区上的所有数据，这表执行一个delete的sql效率高多了
* 想要使用一个包含有日期或时间值，或包含有从一些其他级数开始增长的值的列
* 经常运行直接依赖于用于分区列的查询。例如经常执行"select * from table where year = 2013"，这样的查询，MySql会迅速的确定只有p2分区需要扫描

#####list分区
range分区的使用最为广泛，因为它可以将连续的数据放到一个分区中，在我们使用分区表的场景中这样的情况也最常见，如按照年份将数据分开存放。但是，个别情况下，如果我们希望数据的存放不按照某种连续的规则，而是可以人为的指定某条数据存在哪个分区，比如针对上面的例子，我们希望2008年的数据存在p1分区，这个时候就要使用另外一种分区方式：list分区了。

list分区很多方面类似于range分区，每个分区存放那些数据必须明确定义。他们的主要区别是，list分区的定义和选择是：某列的值从属于一个列表；range分区是：某些的值从属于一个区间。

下面是创建list分区的方式：

	create table partition_list(
		id int not null,
		year int not NULL
	)ENGINE=INNODB
 	 partition by list(year)(
		partition p0 values in (2007,2009,2010),
		partition p1 values in (2008,2011),
		partition p2 values in (2012)
	 )
	 
可以看到，我们可以人为的控制某个年份的数据存在哪个分区中。如果你是个细心的人，可能会问如果我要保存2013年的数据，这个数据会存在哪个分区？（我们没有定义2013年应该在哪个分区）这个时候MySql也不知道该存在哪个分区，所以它拒绝执行插入，会直接报如下的错误：
	
	ERROR 1526 (HY000): Table has no partition for value 2013
	
从上面也可以看出，list分区也有自身的局限性，分区列的值必须是有限个或者当时是有限的（比如年份虽然是无限个的，但是我们可以提前定义一小段时间，比如先定义到2020年，以后再重新定义分区规则）。
  
#####hash分区
range分区和list分区没有办法做到的一点是：数据平均分配在N个分区中。hash分区恰恰可以做到这点。

在hash分区中，MySql自动决定数据该存放在那个分区，我们要做的只是提供给hash函数一个分区列或表达式，以及我们期望的分区数。

如下所示：

	create table partition_hash(
		id int not null,
		year int not null
	)engine=innodb
	partition by hash(year)
	partitions 4
	
MySql会将所有数据平均分成4份，放在4个分区中。如果没有指定分区数，也就是`partitions 4`，则默认任务分区数为1。

哈希表达式可以是MySql中任何函数或其他表达式，只要他返回一个既非常数、又飞随机数的整数。（换句话说，它既是变化的但又是确定的）。但是应当记住，每当插入或更新（或者可能删除）一行，这个表达式都要计算一次；这意味着非常复杂的表达式可能会引起性能问题，尤其是在执行同时影响大量行的运算（例如批量插入）的时候。

最有效率的哈希函数是只对单个表列进行计算，并且它的值随列值进行一致地增大或减小，因为这考虑了在分区范围上的“修剪”。也就是说，表达式值和它所基于的列的值变化越接近，MySQL就可以越有效地使用该表达式来进行HASH分区。

例如，“date_col” 是一个DATE（日期）类型的列，那么表达式TO_DAYS(date_col)就可以说是随列“date_col”值的变化而发生直接的变化，因为列“date_col”值的每个变化，表达式的值也将发生与之一致的变化。而表达式YEAR(date_col)的变化就没有表达式TO_DAYS(date_col)那么直接，因为不是列“date_col”每次可能的改变都能使表达式YEAR(date_col)发生同等的改变。即便如此，表达式YEAR(date_col)也还是一个用于 哈希函数的、好的候选表达式，因为它随列date_col的一部分发生直接变化，并且列date_col的变化不可能引起表达式YEAR(date_col)不成比例的变化。

作为对照，假定有一个类型为整型（INT）的、列名为“int_col”的列。现在考虑表达式“POW(5-int_col,3) + 6”。这对于哈希函数就是一个不好的选择，因为“int_col”值的变化并不能保证表达式产生成比例的变化。列 “int_col”的值发生一个给定数目的变化，可能会引起表达式的值产生一个很大不同的变化。例如，把列“int_col”的值从5变为6，表达式的值将产生“－1”的改变，但是把列“int_col”的值从6变为7时，表达式的值将产生“－7”的变化。

换句话说，如果列值与表达式值之比的曲线图越接近由等式“y=nx（其中n为非零的常数）描绘出的直线，则该表达式越适合于 哈希。这是因为，表达式的非线性越严重，分区中数据产生非均衡分布的趋势也将越严重。

理论上讲，对于涉及到多列的表达式，“修剪（pruning）”也是可能的，但是要确定哪些适于 哈希是非常困难和耗时的。基于这个原因，实际上不推荐使用涉及到多列的哈希表达式。

#####key分区
敬请期待

#####子分区
敬请期待

###分区表使用场景和限制
任何的技术都有其适用的场景，在下面的场景中，分区可以起到非常大的作用：

* 表非常大，以至于无法全部放到内存中，或者只在表的最后部分有热点数据，其他均是历史数据
* 分区表的维护更容易，因此想批量删除大量数据可以使用清楚整个分区的方法。另外，还可以独立对一个分区进行优化、检查、修复、备份、恢复等操作
* 分区表的数据可以分布在不同的设备上，从而高效地利用多个硬件设备
* 可以使用分区表来避免某些特殊的瓶颈，例如innoDB的单个索引的互斥访问等

 
 以上场景可以让分区尽可能的发挥它的作用，同时分区也有自己的一些限制，下面是比较重要的几点：
 
 + 一个表最多有1024个分区
 + 有些情况下分区表达式必须是整数，或者返回整数的表达式
 + 如过有唯一键（包括主键），那么所有的唯一键必须都包含分区字段
 + 分区表中无法使用外键约束
 + 不是所有存储引擎都支持分区表

###分区表维护
敬请期待