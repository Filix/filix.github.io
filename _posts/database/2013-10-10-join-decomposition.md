---
layout: post
title: MySql存储引擎
tag: [database]
keywords: 子非吾,MySql,关联分解,join decomposition,查询优化,sql优化
---
#分解关联查询
在刚开始接触数据库开发时，是不是听过前辈的经验之谈--“尽可能多的把处理过程交给mysql去做”？前辈们的话是经验之谈，大多数情况下我们都可以完全接受，但是今天，我们偏偏要背道而驰。这不是叛逆心理，而是我们知道，我们的背道而驰是有道理的。

前辈的话是有他们的处境的，在他们开始接触开发时，网络通信、查询解析和优化是一件代价很高的事情。但是这些想法对MySql是不适用的，MySql从设计上让连接和断开都是轻量级的，在返回小的查询结果方面很高效。另外，现在的网络速度比以前快的多，无论是带宽还是延迟。

MySql内部每秒可以扫描内存中的上百万条数据，相比之下，MySql相应数据给客户端就慢的多了。在其他条件都相同的时候，使用尽可能少的查询当然是更好的。但是有时候将一个大的查询分解为多个小的查询也是恨有必要的，下面通过一个简单的实例来说明。

	select * from posts 
	inner join tag_post on tag_post.tag_id = tags.id
	inner join tags on tag_post.post_id = posts.id
	where tags.tag = 'mysql';
	
上面的sql可以分解为下面3条小的查询实现：

	select id from tags where tag = 'mysql';
	select post_id from tag_post where tag_id = 1234;
	select * from posts where id in (1,2,4,7,8,9);
	
￼到底为什么这么做？乍一看，这样做没有任何好处，原来一条查询，现在是三条，返回的结果是一模一样的，反而增加了应用程序的复杂度。事实上，用分解关联查询的方式重构有如下优点：   

1. 让缓存更高效。许多应用程序可以方便的缓存对单表的查询结果。例如，上面的查询中tag已被缓存了，那么第一个sql不会触发查询。再例如，应用已经缓存了id为1，2，4的post，那么in()中就可以少几个id了。另外，对于MySql自身的查询缓存来说，如果关联中的某个表发生了变化，那么就无法使用缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以复用缓存了。
2. 分解后，执行单个查询可以减少锁的竞争。
3. 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。
4. 查询本身效率也会有所提升。在这个例子中，使用in()代替关联查询，可以让MySql按照id顺序查询，这可能要比随机的关联要更高效。
5. 可以减少冗余记录的查询。在应用层做关联查询，以为着对于某条记录应用只需要查询一次，而在数据库层做关联查询，则可能需要重复访问一部分数据。从这点看，这样的重构还会减少网络和内存的消耗。
6. 更进一步，这样做相当于实现了哈希关联，而不是使用MySql的嵌套循环关联。在某些场景哈希关联的效率要高很多。


以上就是分解关联查询的一些优点。用过NOSQL的同学是不是发现有点类似把MySql当做key-value数据库使用了呢？听说一些大的互联网公司早就禁止使用关联查询了，都拆分成对单表的查询，这样更能充分使用索引，而且还会避免一些复杂的查询，导致无法使用现有索引的糟糕局面。

最后，说个题外话，本人曾在工作中因为关联查询使用不当，造成的上线后数据库瞬间gone away。后来的解决方法就是这样，拆！

enjoy！