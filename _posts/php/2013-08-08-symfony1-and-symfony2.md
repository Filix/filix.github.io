---
layout: post
title: Symfony1.4和2.1比较
tag: [php]
---
Symfony是一个重量级的php框架。与一些轻量级的php框架（比如CI）相比，Symfony要复杂的多，上手也更困难。对于中文用户来说，Symfony缺少中文文档更使得这个强大的框架在国内的发展举步维艰（虽然symfony的英文文档很丰富，国外社区也很活跃，使用的也很普遍，但是对中文用户的关注太少，使得国内使用着寥寥无几，本人也接触过一些国内使用者，都感叹上手比较难而放弃这个框架，因此本人也有打算翻译symfony的文档，这是后话了）。

这篇文章先大概的介绍一下Symfony的两个版本（1.4和2.1）。以便让未使用过的同学有个了解。

先说说本人的使用经验。本人从Symfony1.4开始接触这个框架，大概用了两年的，这两年里多的项目都是用1.4开发，所以对1.4还是比较熟悉的。有困惑的同学也可以找我一起探讨下。从12年11月开始使用symfony2.1，到现在（13年4月）差不多半年了，对Symfony2.1尚不能称之为熟悉，一般的开发还是没问题的。

了解这两个版本的开发者都应该知道，这两个版本其实完全是两个框架，没有任何的可升级性可言。

下面介绍两个版本，写文章时，本人没有查阅相关资料，完全凭借自己的了解和理解，有错误的地方还望读者指出，谢谢。

1. 应用程序概念

    1.4有应用程序（app）这个概念，Symfony2（包括2.1）没有。1.4允许一个项目框架里有多个应用程序，所以有多个前端控制器，这样可以很方便的将不同域名下的请求指定到不同的前端控制器（比如整个项目有两个应用程序，比如视频对应域名v.mydomain.com,图片对应域名photo.mydomain.com，那么要有两个生产环境的前端控制器比如v.php和photo.php，所以我们可以在web服务器端做设置，让所有v域名下的请求进入到v.php，所有对photo域名下的请求进入到photo.php）。但是Symfony2不是这样，它只有一个前端控制器app.php，如果我们将视频和图片的程序写到一个项目里，那么如果一个视频的详情页的url是v.mydomain.com/123.html那么使用photo.mydomain.com/123.html同样可以访问到该视频。可能有写同学说这不是很严重，用户一般不会知道这个情况。的确，如果只有这个影响的话，坏处不算大。但是，这个问题导致的严重问题是这两个应用不能有相同的url，图片项目就不能有photo.mydomain.com/12345.html这样的路由了！解决的方法可能也简单，用两套项目就好了嘛。但是不同的应用里如果有相同的东西又怎么办？比如说用户。作者没有深入探讨这个问题如何解决，可能需要自己重新路由类，但确实跟1.4比起来麻烦了一些。(Symfony2.2已经解决了这个问题，但是2.1版本的尚未解决，更苦逼的是2.1的维护已经停在了2.1.11上，使用2.1的用户只能苦逼了。。。

2. ORM工具  Doctrine

    ORM是object relation mapping的简称，即对象关系映射。它最大的作用就是把对数据库的操作抽象成对象的操作。ORM将表抽象成类，将表中的没条记录抽象成这个类的一个实例，而表的每个字段则成为这个对象的一个属性。增加一条记录就变为新实例化一个对象，修改一个字段的内容则变为修改这个对象的一个属性。在oop过程中，确实带来了不少方便。Symfony默认使用Doctrine1.2，而Symfony2则默认使用了Doctrine2。所以这里我们就一起讨论Doctrine的这两个版本的区别。Doctrine2从1发展而来，这里主要讨论Doctrine2有哪些变化。当本人第一次使用Doctrine2,发现比Doctrine1用起来不那么方便了（读者可以自己去实践，这里不啰嗦了），但是随之带来的是很大的性能改善。举个例子，在Doctrine1中：
    
    MyTable::getInstance()->find($id);

会出发一条sql查询，类似的方法，在Doctrine2中：

    $this->getMyRepository()->find($id);

会返回一个proxy对象，该对象继承自My这个对象。为什么返回的是代理对象而不是真实的对象？因为在这行代码并没有触发sql查询！只有在下面我们显示的获取这个对象从表中映射出来的属性时，才会触发这个sql。假如这个表有个字段name，当我们调用这个对象的getName()方法时才会真正的出发sql，如果没有这样的调用就不会出发sql。所以Doctrine2聪明到不会轻易跟数据库打交道。

另外还有一点，如果我们像下面这样使用：

    $entity = $this->getMyRepository()->find($id);
    echo $entity->getName();
    $entity = $this->getMyRepository()->find($id);
    echo $entity->getName();

相同的代码重复了两次，在Dcotrine2中只会出发一条sql，也就是说，Doctrine2会管理我们从数据库获取到的所有对象，当下一次要获取一个已经得到的对象时，直接返回而不是从数据库去获取。